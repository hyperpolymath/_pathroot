= _pathroot for Morons
:author: Hyper Polymath
:email: hyperpolymath@example.com
:revnumber: 0.1.0
:revdate: 2025-01-15
:revremark: Initial release
:doctype: book
:toc: left
:toclevels: 3
:sectnums:
:icons: font
:source-highlighter: rouge
:experimental:
:imagesdir: images

// PDF-specific settings
ifdef::backend-pdf[]
:title-logo-image: image:pathroot-logo.png[pdfwidth=4cm,align=center]
endif::[]

[abstract]
--
An Open Guide to Modular Devtools Environments.

This guide walks you through a modular devtools scaffold built for clarity, introspection, and automation. It's designed to be teachable, tweakable, and explainable—so you can understand not just _what_ it does, but _why_ it does it.
--

== Introduction

Welcome, Head of DevOps. As you read, consider:

* What assumptions are being made?
* How might this scale or evolve?
* What would you do differently?

=== The Problem We're Solving

Modern dev environments are messy:

* Scripts break when paths change
* Tools get lost in the filesystem
* Configs are duplicated or hardcoded
* Environment variables become unmanageable

=== What We Want

A system that:

[cols="1,2"]
|===
|Goal |Description

|Discoverable
|Can be found from anywhere in the filesystem

|Self-aware
|Knows what kind of environment it's in

|Automatable
|Easy to scaffold, inspect, and script

|Maintainable
|Simple enough to understand and modify
|===

== Core Concepts: Two Markers, Two Roles

The _pathroot system uses two complementary markers.

=== The Global Marker: `_pathroot`

*Location:* `C:\_pathroot` (or drive root on other systems)

*Purpose:* Tells any tool "Here's the root of the devtools universe."

[cols="1,2"]
|===
|Property |Value

|Placement |Drive level (e.g., `C:\`)
|Scope |System-wide discovery
|Contents |Path to devtools (e.g., `C:\devtools`)
|===

TIP: Think of `_pathroot` as *GPS coordinates*. It tells you _where_ you are.

=== The Local Marker: `_envbase`

*Location:* `C:\devtools\_envbase` (inside the devtools root)

*Purpose:* Describes the environment with structured metadata.

.Example _envbase content
[source,json]
----
{
  "env": "devtools",
  "profile": "default",
  "platform": "windows"
}
----

TIP: Think of `_envbase` as the *weather report*. It tells you _what_ conditions you're in.

=== Why Both?

[cols="1,2"]
|===
|Marker |Question It Answers

|`_pathroot` |"Where are my devtools?"
|`_envbase` |"What kind of environment is this?"
|===

== Directory Structure

The _pathroot system uses a standardized directory layout.

----
C:\devtools\
├── bin\        # Executables
├── scripts\    # Utility scripts
├── config\     # Configuration files
├── logs\       # Log outputs
├── temp\       # Temporary files
├── tools\      # Installed packages
├── _envbase    # Local environment metadata

C:\_pathroot    # Global root marker (at drive level)
----

=== Directory Purposes

[cols="1,2,2"]
|===
|Directory |Purpose |Examples

|`bin/` |Executable binaries |`tool.exe`, `compiler.exe`
|`scripts/` |Utility scripts |`build.ps1`, `deploy.bat`
|`config/` |Configuration files |`settings.json`, `profiles.yaml`
|`logs/` |Log outputs |`build.log`, `link-audit.txt`
|`temp/` |Temporary files |Build artifacts, caches
|`tools/` |Installed packages |Version-managed tools
|===

== Scripts Reference

=== Windows: Create _pathroot (CMD)

[source,batch]
----
:: Create _pathroot file pointing to devtools root
echo C:\devtools > C:\_pathroot
----

=== Windows: Read _pathroot (PowerShell)

[source,powershell]
----
# Read _pathroot and store in variable
$Pathroot = Get-Content -Path "C:\_pathroot"
Write-Host "Devtools root is at: $Pathroot"
----

=== Windows: Create _envbase (PowerShell)

[source,powershell]
----
# Create _envbase file with basic metadata
$envbase = @{
    env      = "devtools"
    profile  = "default"
    platform = "windows"
}
$envbase | ConvertTo-Json -Depth 3 | Set-Content -Path "C:\devtools\_envbase"
----

=== Windows: Read _envbase (PowerShell)

[source,powershell]
----
# Read and parse _envbase metadata
$envbase = Get-Content -Path "C:\devtools\_envbase" | ConvertFrom-Json
Write-Host "Environment: $($envbase.env)"
Write-Host "Profile: $($envbase.profile)"
Write-Host "Platform: $($envbase.platform)"
----

=== Cross-Platform: Guile Scheme Discovery

[source,scheme]
----
(define (read-pathroot)
  (call-with-input-file "C:/_pathroot"
    (lambda (port) (read-line port))))

(display (string-append "Devtools root: " (read-pathroot)))
----

=== Safe Link Creation with Audit Log

[source,powershell]
----
# Create symbolic link and log action
$src = "C:\devtools\bin\tool.exe"
$dst = "C:\tools\tool.exe"
New-Item -ItemType SymbolicLink -Path $dst -Target $src
Add-Content -Path "C:\devtools\logs\link-audit.txt" -Value "$dst -> $src"
----

== Frequently Asked Questions

=== What is `_pathroot` and why is it on my C: drive?

`_pathroot` is a file that tells your system where the devtools live. It's like a treasure map with only one clue:

[quote]
Go to C:\devtools.

Any script or tool can read this file and instantly know where to find the good stuff—your binaries, configs, logs, and more.

=== What happens if I delete `_pathroot`?

Your tools will get lost. Scripts won't know where to look. Your Head of DevOps will sigh audibly.

*Just don't do it.*

If you did, recreate it with:

[source,batch]
----
echo C:\devtools > C:\_pathroot
----

=== Can I rename `_pathroot` to something cooler?

You _can_, but you'll break everything unless you update all your scripts to look for the new name.

Stick with `_pathroot`. It's boring, but it works.

=== Can I have multiple `_envbase` files?

Yes, but only if your tooling supports it. You could use:

* `_envbase.default`
* `_envbase.test`
* `_envbase.wsl`

Then switch between them with a script. But keep one active at a time unless you like chaos.

=== Why is there a cyborg sheepdog on the cover?

Because this system is designed to rescue you from falling into bytecode hell. And because it's funny. And because your Head of DevOps deserves joy.

== Integration Guide

=== RapidEE Integration

https://www.rapidee.com/[RapidEE] is a Windows environment variables editor.

.Recommended Setup
. Add devtools bin to PATH
. Create `DEVTOOLS_ROOT` variable pointing to `C:\devtools`
. Create `PATHROOT` variable pointing to `C:\_pathroot` (optional)

=== modshells Integration

Add to your modshells profile:

[source,powershell]
----
# Load _pathroot environment
$PathrootFile = "C:\_pathroot"
if (Test-Path $PathrootFile) {
    $env:DEVTOOLS_ROOT = (Get-Content $PathrootFile).Trim()
    $env:PATH = "$env:DEVTOOLS_ROOT\bin;$env:PATH"
}
----

=== TUI Integration

The Ada-based TUI provides interactive management with a transaction protocol:

[source]
----
PATHROOT:QUERY:ENV
PATHROOT:SET:PROFILE:test
PATHROOT:LINK:src:dst
PATHROOT:AUDIT:links
----

== Cross-Platform Considerations

[cols="1,2,2"]
|===
|Platform |Pathroot Location |Devtools Root

|Windows |`C:\_pathroot` |`C:\devtools`
|WSL |`/mnt/c/_pathroot` |`/opt/devtools`
|Linux |`/_pathroot` |`/opt/devtools`
|macOS |`/_pathroot` |`/opt/devtools`
|===

[appendix]
== Quick Reference Card

.Essential Commands
[cols="2,3"]
|===
|Action |Command

|Create scaffold
|`automkdir.bat` (Windows) or `pathroot.sh init` (POSIX)

|Inspect environment
|`envbase.ps1` (Windows) or `pathroot.sh info` (POSIX)

|Validate setup
|`deno run --allow-read --allow-env src/validate.ts`

|Switch profile
|`pathroot.sh profile test`
|===

[appendix]
== Version History

[cols="1,1,3"]
|===
|Version |Date |Changes

|0.1.0 |2025-01-15 |Initial release with core functionality
|===

[colophon]
== Colophon

This document is part of the _pathroot project.

* Repository: https://gitlab.com/hyperpolymath/_pathroot
* License: AGPL-3.0-or-later
* Build tool: Asciidoctor PDF

To generate PDF:

[source,bash]
----
asciidoctor-pdf docs/pathroot-guide.adoc -o docs/pathroot-guide.pdf
----
